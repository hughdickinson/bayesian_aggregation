import os
import itertools
import json
import matplotlib
import matplotlib.pyplot as mplplot
import pandas as pd
import numpy as np
import pickle
import collections


class BBoxResultsPlotter:
    def __init__(
        self,
        aggregatedDataPath,
        imageMetaDataPath,
        inputAnnotations,
        imageDir=".",
        imagePathColumn="image_path",
        imagePathSuffix=".png",
    ):
        """
        Args:
        aggregatedDataPath - Path to a JSON-format aggregator output file.
        imageMetaDataPath - Path to a pickled `pandas.DataFrame` with columns
        that must include "image_id" providing a unique index for  the image to
        be plotted and "subject_id", providing the unique ID generated by the
        Panoptes platform.
        inputAnnotations - A list containing the input annotations provided to
        the aggregator.
        imageDir - Path to directory containing the annotated images.
        imagePathColumn - The name of the column in the metadata DataFrame containing
        the subject image paths relative to `imageDir`.
        imagePathSuffix - Suffix to append to the values in `imagePathColumn` to form
        a valid image file name (default: '.png')
        """
        with open(aggregatedDataPath) as aggregatedDataFile:
            self.aggregatedData = json.load(aggregatedDataFile)
        self.imageMetaData = pd.read_pickle(imageMetaDataPath)
        # self.inputData = inputData
        self.imageDir = imageDir
        self.imagePathColumn = imagePathColumn
        self.imagePathSuffix = imagePathSuffix
        self.risks = None
        self.imageDimensions = None
        self.completionStates = None
        self.annotations = None
        self.inputAnnotations = inputAnnotations
        self.inputAnnotationDict = {}

    def processInputData(self):
        for annotation in self.inputAnnotations:
            if annotation["image_id"] in self.inputAnnotationDict:
                if (
                    annotation["worker_id"]
                    in self.inputAnnotationDict[annotation["image_id"]]
                ):
                    self.inputAnnotationDict[annotation["image_id"]][
                        annotation["worker_id"]
                    ].append(annotation)
                else:
                    self.inputAnnotationDict[annotation["image_id"]][
                        annotation["worker_id"]
                    ] = [annotation]
            else:
                self.inputAnnotationDict[annotation["image_id"]] = {
                    annotation["worker_id"]: [annotation]
                }

        self.extractRisks()
        self.extractImageDimensions()
        self.extractCompletionStates()
        self.extractAnnotations()

    def extractRisks(self):
        self.risks = {
            int(imageId): image["risk"]
            for imageId, image in self.aggregatedData["images"].items()
        }

    def extractSkillSigmas(self):
        self.skillSigmas = {
            int(np.nan_to_num(float(workerId))): worker["sigma"]
            for workerId, worker in self.aggregatedData["workers"].items()
        }

    def extractSkillFalsePosProbs(self):
        self.skillFalsePosProbs = {
            int(np.nan_to_num(float(workerId))): worker["prob_fp"]
            for workerId, worker in self.aggregatedData["workers"].items()
        }

    def extractSkillFalseNegProbs(self):
        self.skillFalseNegProbs = {
            int(np.nan_to_num(float(workerId))): worker["prob_fn"]
            for workerId, worker in self.aggregatedData["workers"].items()
        }

    def extractSubjectClassificationCounts(self):
        self.subjectClassificationCounts = {
            int(subjectId): len(subjectAnnotations)
            for subjectId, subjectAnnotations in self.inputAnnotationDict.items()
        }

    def extractCompletionStates(self):
        self.completionStates = {
            int(imageId): image["finished"]
            for imageId, image in self.aggregatedData["images"].items()
        }

    def extractImageDimensions(self):
        self.imageDimensions = {
            int(imageId): (image["width"], image["height"])
            for imageId, image in self.aggregatedData["images"].items()
        }

    def extractAnnotations(self):
        default_category_id = 0
        anno_id = itertools.count(0)

        self.annotations = [
            {
                "image_id": label["image_id"],
                "category_id": default_category_id,
                "bbox": [
                    bbox["x"],
                    bbox["y"],
                    bbox["x2"] - bbox["x"],
                    bbox["y2"] - bbox["y"],
                ],
                "id": next(anno_id),
            }
            for labelCounter, label in enumerate(self.aggregatedData["combined_labels"])
            for bbox in label["label"]["bboxes"]
        ]

    def plotExamples(
        self,
        numExamples,
        gridWidth=3,
        showLegend=False,
        selector=None,
        invertColours=False,
    ):
        unifiedFigureShape = np.array([gridWidth, numExamples // gridWidth])
        unifiedFigurePadSize = 6

        unifiedFigure, unifiedPanels = mplplot.subplots(
            figsize=unifiedFigureShape * unifiedFigurePadSize,
            ncols=unifiedFigureShape[0],
            nrows=unifiedFigureShape[1],
        )

        if showLegend:
            panelSlice = slice(0, -1, 1)
        else:
            panelSlice = slice(None)

        if selector is not None:
            selectedImageMetaData = self.imageMetaData.loc[selector]
        else:
            selectedImageMetaData = self.imageMetaData

        selectedImageIds = np.random.choice(
            selectedImageMetaData.image_id.unique(),
            size=numExamples - int(showLegend),
            replace=False,
        )

        selectedImageMetaData = selectedImageMetaData[
            selectedImageMetaData.image_id.apply(
                lambda imageId: imageId in selectedImageIds
            )
        ]

        allLabels = []
        allHandles = []

        for unifiedPanel, (imageIndex, groundTruth) in zip(
            unifiedPanels.flatten()[panelSlice],
            selectedImageMetaData.groupby(by="image_id"),
        ):

            groundTruth = groundTruth.sort_values(by="subject_id").head(1)
            subjectId = np.asscalar(groundTruth.subject_id)

            imageAnnotations = [
                annotation
                for annotation in self.annotations
                if int(annotation["image_id"]) == subjectId
            ]

            if self.imagePathColumn in groundTruth.columns:
                imagePath = str(groundTruth[self.imagePathColumn].values[0])
                if self.imagePathSuffix is not None:
                    imagePath += self.imagePathSuffix
                #                 print(type(imagePath), imagePath)
                if not os.path.isabs(imagePath):
                    imagePath = os.path.join(self.imageDir, imagePath)
            else:
                imagePath = os.path.join(
                    self.imageDir, "subject_{}.png".format(imageIndex)
                )

            imageData = mplplot.imread(imagePath)
            if invertColours:
                imageData[..., :-1] = (
                    np.ones_like(imageData[..., :-1]) - imageData[..., :-1]
                )
            unifiedPanel.imshow(imageData, origin="lower", zorder=0)

            for imageAnnotation in imageAnnotations:
                unifiedPanel.add_patch(
                    matplotlib.patches.Rectangle(
                        [imageAnnotation["bbox"][0], imageAnnotation["bbox"][1]],
                        imageAnnotation["bbox"][2],
                        imageAnnotation["bbox"][3],
                        ec="k",
                        fc="none",
                        alpha=1,
                        zorder=50,
                        lw=2,
                        label="Consensus",
                    )
                )

            uniqueWorkerIds = np.unique(
                np.concatenate(
                    [
                        [int(np.nan_to_num(float(key))) for key in imageAnnos.keys()]
                        for imageAnnos in self.inputAnnotationDict.values()
                    ]
                )
            )
            for workerId, workerAnnotations in self.inputAnnotationDict[
                str(subjectId)
            ].items():
                workerIndex = np.asscalar(
                    np.flatnonzero(
                        uniqueWorkerIds == int(np.nan_to_num(float((workerId))))
                    )
                )
                for bbox in workerAnnotations[0]["anno"]["bboxes"]:
                    unifiedPanel.add_patch(
                        matplotlib.patches.Rectangle(
                            [bbox["x"], bbox["y"]],
                            bbox["x2"] - bbox["x"],
                            bbox["y2"] - bbox["y"],
                            # Anticipate images being finished
                            # within 10 annotations
                            ec="C{}".format(workerIndex % 10),
                            fc="none",
                            alpha=1,
                            zorder=10,
                            label=str(workerIndex),
                        )
                    )

            unifiedPanel.text(
                0.95,
                0.95,
                "$|\mathcal{{W}}|$ = {}".format(
                    len(self.inputAnnotationDict[str(subjectId)])
                ),
                horizontalalignment="right",
                verticalalignment="top",
                fontdict=dict(color="k" if invertColours else "w", fontsize="x-large"),
                transform=unifiedPanel.transAxes,
            )

            if self.completionStates[subjectId]:
                unifiedPanel.text(
                    0.05,
                    0.95,
                    "COMPLETE",
                    horizontalalignment="left",
                    verticalalignment="top",
                    fontdict=dict(
                        color="k" if invertColours else "w", fontsize="x-large"
                    ),
                    transform=unifiedPanel.transAxes,
                )
            else:
                unifiedPanel.text(
                    0.05,
                    0.95,
                    "INCOMPLETE",
                    horizontalalignment="left",
                    verticalalignment="top",
                    fontdict=dict(
                        color="k" if invertColours else "w", fontsize="x-large"
                    ),
                    transform=unifiedPanel.transAxes,
                )

            unifiedPanel.set_title(
                "Simulated Image {}.\n Risk: {:.4e}".format(
                    subjectId, self.risks[subjectId]
                )
            )

            unifiedPanel.set_xlim(0, self.imageDimensions[subjectId][0])
            unifiedPanel.set_ylim(0, self.imageDimensions[subjectId][0])
            unifiedPanel.set_xticks([])
            unifiedPanel.set_yticks([])

            handles, labels = unifiedPanel.get_legend_handles_labels()
            allHandles.extend(handles)
            allLabels.extend(labels)

        uniqueLabels = np.unique(allLabels)
        uniqueLabelIndices = [
            allLabels.index(uniqueLabel) for uniqueLabel in uniqueLabels
        ]

        if showLegend:
            legendAxes = unifiedPanels.flatten()[-1]
            legendAxes.axis("off")
            legendAxes.legend(
                np.array(allHandles)[uniqueLabelIndices],
                np.array(allLabels)[uniqueLabelIndices],
                loc="center",
                fontsize="x-large",
                title="Workers",
            ).get_title().set_fontsize("xx-large")

        mplplot.tight_layout()
        return unifiedFigure, unifiedPanels

    def plotRisks(self, threshold=None, logAxes=False):
        riskAxes = mplplot.figure(figsize=(6, 6)).add_subplot(1, 1, 1)
        riskData = np.fromiter(self.risks.values(), dtype=np.float64)

        incompleteRiskData = [
            risk
            for subjectId, risk in self.risks.items()
            if not self.completionStates[subjectId]
        ]

        completeRiskData = [
            risk
            for subjectId, risk in self.risks.items()
            if self.completionStates[subjectId]
        ]

        if logAxes:
            riskBins = np.logspace(
                np.log10(riskData.min()), np.log10(riskData.max()), riskData.size // 10
            )
            riskAxes.set_xscale("log")
        else:
            riskBins = np.linspace(
                np.log10(riskData.min()), np.log10(riskData.max()), riskData.size // 10
            )

        thresholdInRange = (
            threshold is not None
            and threshold > riskData.min()
            and threshold < riskData.max()
        )

        if thresholdInRange:
            riskBins = np.sort(np.append(riskBins, threshold))

        riskAxes.hist(completeRiskData, bins=riskBins, label="Complete")
        riskAxes.hist(incompleteRiskData, bins=riskBins, label="Incomplete")

        if thresholdInRange:
            riskAxes.axvline(
                x=threshold,
                label="$R_{{thresh}}$ = {:.2e}".format(threshold),
                c="r",
                ls="--",
            )

        riskAxes.set_xlabel("Risk")
        riskAxes.set_ylabel("Subject Count")
        if logAxes:
            riskAxes.set_xscale("log")
        riskAxes.legend()
        mplplot.tight_layout()

    @staticmethod
    def plotUserData(aggregator, savePath=".", savePrefix=None):
        workers = aggregator.workers

        maxBatches = np.amax(
            [len(worker.sigma_array) for worker in aggregator.workers.values()]
        )

        if len(workers) > 0:
            figure, panels = mplplot.subplots(figsize=(50, 20), nrows=3, ncols=5)
            numFigure, numPanels = mplplot.subplots(
                figsize=(5, 10),
                nrows=4,
                ncols=2,
                gridspec_kw=dict(width_ratios=[1, 0.2], height_ratios=[1, 0.2, 1, 0.2]),
            )
            numBoxPanel = mplplot.figure(figsize=(10, 10)).add_subplot(1, 1, 1)
            numFpDicts = {}
            numFnDicts = {}
            allWorkerIds = []
            allWorkerBBoxCounts = {}
            for workerId, worker in workers.items():
                if workerId not in allWorkerIds:
                    allWorkerIds.append(int(workerId))

                # workerImageIds, workerImages = worker.images.items()
                for workerImageId, workerImage in worker.images.items():
                    if workerImageId in allWorkerBBoxCounts:
                        allWorkerBBoxCounts[workerImageId].append(
                            len(workerImage.y.bboxes)
                        )
                    else:
                        allWorkerBBoxCounts[workerImageId] = [len(workerImage.y.bboxes)]

                numFpDicts[int(workerId)] = {}
                numFnDicts[int(workerId)] = {}

                numBatches = len(worker.sigma_array)

                # Data for final iteration of all batches
                try:
                    finalBatchwiseSigmas = [
                        batchArray[-1] for batchArray in worker.sigma_array
                    ]

                    finalBatchwiseFalsePosProbs = [
                        batchArray[-1] for batchArray in worker.prob_fp_array
                    ]
                    finalBatchwiseFalseNegProbs = [
                        batchArray[-1] for batchArray in worker.prob_fn_array
                    ]

                    finalBatchwiseNumFalsePos = [
                        batchArray[-1] for batchArray in worker.num_fp_array
                    ]
                    finalBatchwiseNumFalseNeg = [
                        batchArray[-1] for batchArray in worker.num_fn_array
                    ]

                    finalBatchwiseSigmaDeltas = [
                        batchArray[-1] for batchArray in worker.dsigma_array
                    ]
                    finalBatchwiseFalsePosProbDeltas = [
                        batchArray[-1] for batchArray in worker.dprob_fp_array
                    ]
                    finalBatchwiseFalseNegProbDeltas = [
                        batchArray[-1] for batchArray in worker.dprob_fn_array
                    ]

                    finalBatchwiseImageIds = [
                        batchArray[-1] for batchArray in worker.image_id_array
                    ]
                except IndexError as e:
                    print(
                        "plotUserData: Caught IndexError: {} ()".format(
                            e, [len(batchArray) for batchArray in worker.sigma_array]
                        )
                    )
                    continue

                # Result of processing the final iteration with all batches considered
                sigmas = finalBatchwiseSigmas[-1]
                falsePosProbs = finalBatchwiseFalsePosProbs[-1]
                falseNegProbs = finalBatchwiseFalseNegProbs[-1]

                numFalsePos = finalBatchwiseNumFalsePos[-1]
                numFalseNeg = finalBatchwiseNumFalseNeg[-1]

                sigmaDeltas = finalBatchwiseSigmaDeltas[-1]
                falsePosProbDeltas = finalBatchwiseFalsePosProbDeltas[-1]
                falseNegProbDeltas = finalBatchwiseFalseNegProbDeltas[-1]

                imageIds = finalBatchwiseImageIds[-1]

                for imageId, nFalsePos, nFalseNeg in zip(
                    imageIds, numFalsePos, numFalseNeg
                ):
                    if int(imageId) in numFpDicts[int(workerId)]:
                        numFpDicts[int(workerId)][int(imageId)] += nFalsePos
                    else:
                        numFpDicts[int(workerId)][int(imageId)] = nFalsePos

                    if int(imageId) in numFnDicts[int(workerId)]:
                        numFnDicts[int(workerId)][int(imageId)] += nFalseNeg
                    else:
                        numFnDicts[int(workerId)][int(imageId)] = nFalseNeg

                # Compute difference in metric induced by each batch
                # Sum absolute and signed offsets for corresponding elements
                # Note that not all workers will contribute to all batches.

                # Workers will not have data until they first appear, but they
                # will have empty data for any subsequent batches to which they
                # do not contribute

                batchSummedSignedDiffs = {
                    name: [np.nan] * (maxBatches - numBatches)
                    + [
                        np.sum(
                            np.array(data[current][-1])
                            - np.array(data[current - 1][-1])
                        )
                        for current in range(1, len(data))
                    ]
                    for name, data in zip(
                        ["sigma", "falsePosProb", "falseNegProb"],
                        [
                            finalBatchwiseSigmas,
                            finalBatchwiseFalsePosProbs,
                            finalBatchwiseFalseNegProbs,
                        ],
                    )
                }
                batchSummedAbsDiffs = {
                    name: [np.nan] * (maxBatches - numBatches)
                    + [
                        np.sum(
                            np.abs(
                                np.array(data[current][-1])
                                - np.array(data[current - 1][-1])
                            )
                        )
                        for current in range(1, len(data))
                    ]
                    for name, data in zip(
                        ["sigma", "falsePosProb", "falseNegProb"],
                        [
                            finalBatchwiseSigmas,
                            finalBatchwiseFalsePosProbs,
                            finalBatchwiseFalseNegProbs,
                        ],
                    )
                }

                ## False pos and false neg probabilities and evolution
                for (
                    panelSet,
                    imageIdSet,
                    dataset,
                    deltaDataset,
                    signedDiffDataset,
                    absDiffDataset,
                    title,
                ) in zip(
                    panels,
                    [[imageIds]] * len(panels),
                    [sigmas, falsePosProbs, falseNegProbs],
                    [sigmaDeltas, falsePosProbDeltas, falseNegProbDeltas],
                    [
                        batchSummedSignedDiffs["sigma"],
                        batchSummedSignedDiffs["falsePosProb"],
                        batchSummedSignedDiffs["falseNegProb"],
                    ],
                    [
                        batchSummedAbsDiffs["sigma"],
                        batchSummedAbsDiffs["falsePosProb"],
                        batchSummedAbsDiffs["falseNegProb"],
                    ],
                    ["sigma", "false pos prob", "false neg prob"],
                ):
                    panelSet[0].plot(
                        range(len(dataset)),
                        dataset,
                        ls=":" if worker.suppressed else "-",
                    )
                    panelSet[0].set_ylabel(title, fontsize="x-large")
                    panelSet[0].set_xlabel("Subject count", fontsize="x-large")
                    panelSet[1].set_yscale("log")
                    panelSet[1].set_xscale("log")
                    panelSet[1].plot(
                        range(len(dataset)),
                        dataset,
                        ls=":" if worker.suppressed else "-" if not len(worker.suppressed_images) else ".-",
                    )
                    panelSet[1].set_ylabel(title, fontsize="x-large")
                    panelSet[1].set_xlabel("Subject count", fontsize="x-large")
                    panelSet[2].set_ylabel(
                        "$\Delta$ {}".format(title), fontsize="x-large"
                    )
                    panelSet[2].set_xlabel("Subject ID", fontsize="x-large")
                    panelSet[2].scatter(
                        x=imageIdSet,
                        y=deltaDataset,
                        marker="+" if worker.suppressed else "o" if not len(worker.suppressed_images) else "*",
                    )
                    # panelSet[2].set_yscale("log")
                    # # print(workerId, len(signedDiffDataset), len(absDiffDataset))
                    panelSet[3].plot(
                        range(len(signedDiffDataset)),
                        signedDiffDataset,
                        ls=":" if worker.suppressed else "-" if not len(worker.suppressed_images) else ".-",
                    )
                    panelSet[3].set_title(title, fontsize="x-large")
                    panelSet[3].set_xlabel("Batch count", fontsize="x-large")
                    panelSet[3].set_ylabel(
                        "Inter-batch signed difference sum", fontsize="x-large"
                    )
                    panelSet[4].plot(
                        range(len(absDiffDataset)),
                        absDiffDataset,
                        ls=":" if worker.suppressed else "-",
                    )
                    panelSet[4].set_title(title, fontsize="x-large")
                    panelSet[4].set_xlabel("Batch count", fontsize="x-large")
                    panelSet[4].set_ylabel(
                        "Inter-batch absolute difference sum", fontsize="x-large"
                    )

            mplplot.figure(figure.number)
            mplplot.tight_layout()
            if savePrefix is None:
                savePrefix = "userSkill"
            mplplot.savefig(
                os.path.join(savePath, savePrefix + "_probs.png"), bbox_inches="tight"
            )

            allImageIds = np.sort(
                np.array(
                    list(
                        set(
                            [
                                imageId
                                for workerNumFps in numFpDicts.values()
                                for imageId in workerNumFps.keys()
                            ]
                        )
                    )
                )
            )

            # allWorkerIds = np.array(list(numFpDicts.keys()))

            # fpCounts = np.asarray(
            #     [
            #         [
            #             numFpDicts[workerId][imageId]
            #             if imageId in numFpDicts[workerId]
            #             else np.nan
            #             for imageId in allImageIds
            #         ]
            #         for workerId in allWorkerIds
            #     ]
            # )

            fpCountsScatter = np.asarray(
                [
                    [workerId, imageId, numFpDicts[workerId][imageId]]
                    if imageId in numFpDicts[workerId]
                    else [workerId, imageId, np.nan]
                    for workerId in allWorkerIds
                    for imageId in allImageIds
                ]
            )

            # fnCounts = np.asarray(
            #     [
            #         [
            #             numFnDicts[workerId][imageId]
            #             if imageId in numFnDicts[workerId]
            #             else np.nan
            #             for imageId in allImageIds
            #         ]
            #         for workerId in allWorkerIds
            #     ]
            # )

            fnCountsScatter = np.asarray(
                [
                    [workerId, imageId, numFnDicts[workerId][imageId]]
                    if imageId in numFpDicts[workerId]
                    else [workerId, imageId, np.nan]
                    for workerId in allWorkerIds
                    for imageId in allImageIds
                ]
            )

            # False pos and false neg number counts
            for (panelSet, dataset, title) in zip(
                zip(numPanels[::2], numPanels[1::2]),
                # [fpCounts, fnCounts],
                [fpCountsScatter, fnCountsScatter],
                ["Num FP", "Num FN"],
            ):

                panelSet[0][0].scatter(
                    x=dataset[:, 1], y=dataset[:, 0], s=dataset[:, 2], alpha=0.5
                )
                panelSet[0][0].set_ylabel("Worker ID")
                panelSet[0][0].set_title(title)

                workerSums = [
                    np.nansum(dataset.T[2][dataset.T[0] == workerId])
                    for workerId in allWorkerIds
                ]
                imageSums = [
                    np.nansum(dataset.T[2][dataset.T[1] == imageId])
                    for imageId in allImageIds
                ]

                panelSet[0][1].step(workerSums, range(len(workerSums)), where="pre")
                panelSet[0][1].invert_yaxis()
                panelSet[1][0].step(range(len(imageSums)), imageSums, where="pre")
                panelSet[1][0].set_xlabel("Image ID")
                panelSet[1][1].axis("off")

            mplplot.figure(numFigure.number)
            mplplot.tight_layout()
            if savePrefix is None:
                savePrefix = "userSkill"
            mplplot.savefig(
                os.path.join(savePath, savePrefix + "_counts.png"), bbox_inches="tight"
            )

            numBoxPanel.scatter(
                range(len(allWorkerBBoxCounts.keys())),
                [np.mean(bboxCounts) for bboxCounts in allWorkerBBoxCounts.values()],
            )
            numBoxPanel.set_xlabel("Image ID")
            numBoxPanel.set_xlabel("Mean Aggregated Box Count")
            mplplot.figure(numBoxPanel.figure.number)
            mplplot.tight_layout()
            if savePrefix is None:
                savePrefix = "userSkill"
            mplplot.savefig(
                os.path.join(savePath, savePrefix + "_boxcounts.png"),
                bbox_inches="tight",
            )

    @staticmethod
    def exploreUserSkillsForBatch(
        batchPicklePath, metadataPicklePath, savePath=".", savePrefix=None
    ):
        with open(metadataPicklePath, mode="rb") as mdPickle:
            subjectMetaData = pickle.load(mdPickle)

        # print(*subjectMetaData.columns, sep="\n")

        with open(batchPicklePath, mode="rb") as batchPickle:
            batchWorkerData = pickle.load(batchPickle)
        highFpDeltaWorkers = []
        highFpDeltaImages = []
        highFpDeltaValues = []
        for workerId, worker in batchWorkerData.items():
            # Data for final iteration of all batches for this worker
            finalBatchwiseSigmas = [batchArray[-1] for batchArray in worker.sigma_array]
            finalBatchwiseFalsePosProbs = [
                batchArray[-1] for batchArray in worker.prob_fp_array
            ]
            finalBatchwiseFalseNegProbs = [
                batchArray[-1] for batchArray in worker.prob_fn_array
            ]

            finalBatchwiseSigmaDeltas = [
                batchArray[-1] for batchArray in worker.dsigma_array
            ]
            finalBatchwiseFalsePosProbDeltas = [
                batchArray[-1] for batchArray in worker.dprob_fp_array
            ]
            finalBatchwiseFalseNegProbDeltas = [
                batchArray[-1] for batchArray in worker.dprob_fn_array
            ]

            finalBatchwiseImageIds = [
                batchArray[-1] for batchArray in worker.image_id_array
            ]

            # Get the FP prob sort order for the final batch
            lastBatchSortOrder = np.argsort(finalBatchwiseFalsePosProbDeltas[-1])

            highFpDeltaWorkers.append(workerId)
            highFpDeltaValues.append(
                np.array(finalBatchwiseFalsePosProbDeltas[-1])[lastBatchSortOrder][-1]
            )
            highFpDeltaImages.append(
                np.array(finalBatchwiseImageIds[-1])[lastBatchSortOrder][-1]
            )

        # print(
        #     list(
        #         sorted(
        #             zip(highFpDeltaWorkers, highFpDeltaImages), key=lambda data: data[1]
        #         )
        #     )[-10:]
        # )
        #
        # print(np.array(highFpDeltaImages)[np.argsort(highFpDeltaValues)][-10:])
        # print(
        #     np.array(highFpDeltaImages)[np.array(highFpDeltaValues) > 0.1]
        #     .astype(int)
        #     .tolist()
        # )
        # print(
        #     list(
        #         zip(
        #             np.array(highFpDeltaImages)[
        #                 np.array(highFpDeltaValues) > 0.1
        #             ].astype(int),
        #             np.array(highFpDeltaWorkers)[
        #                 np.array(highFpDeltaValues) > 0.1
        #             ].astype(int),
        #         )
        #     )
        # )
