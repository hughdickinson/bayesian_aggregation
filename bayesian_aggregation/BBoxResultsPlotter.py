import os
import itertools
import json
import matplotlib
import matplotlib.pyplot as mplplot
import pandas as pd
import numpy as np


class BBoxResultsPlotter:
    def __init__(
        self,
        aggregatedDataPath,
        imageMetaDataPath,
        inputAnnotations,
        imageDir=".",
        imagePathColumn="image_path",
        imagePathSuffix=".png",
    ):
        """
        Args:
        aggregatedDataPath - Path to a JSON-format aggregator output file.
        imageMetaDataPath - Path to a pickled `pandas.DataFrame` with columns
        that must include "image_id" providing a unique index for  the image to
        be plotted and "subject_id", providing the unique ID generated by the
        Panoptes platform.
        inputAnnotations - A list containing the input annotations provided to
        the aggregator.
        imageDir - Path to directory containing the annotated images.
        imagePathColumn - The name of the column in the metadata DataFrame containing
        the subject image paths relative to `imageDir`.
        imagePathSuffix - Suffix to append to the values in `imagePathColumn` to form
        a valid image file name (default: '.png')
        """
        with open(aggregatedDataPath) as aggregatedDataFile:
            self.aggregatedData = json.load(aggregatedDataFile)
        self.imageMetaData = pd.read_pickle(imageMetaDataPath)
        # self.inputData = inputData
        self.imageDir = imageDir
        self.imagePathColumn = imagePathColumn
        self.imagePathSuffix = imagePathSuffix
        self.risks = None
        self.imageDimensions = None
        self.completionStates = None
        self.annotations = None
        self.inputAnnotations = inputAnnotations
        self.inputAnnotationDict = {}

    def processInputData(self):
        for annotation in self.inputAnnotations:
            if annotation["image_id"] in self.inputAnnotationDict:
                if (
                    annotation["worker_id"]
                    in self.inputAnnotationDict[annotation["image_id"]]
                ):
                    self.inputAnnotationDict[annotation["image_id"]][
                        annotation["worker_id"]
                    ].append(annotation)
                else:
                    self.inputAnnotationDict[annotation["image_id"]][
                        annotation["worker_id"]
                    ] = [annotation]
            else:
                self.inputAnnotationDict[annotation["image_id"]] = {
                    annotation["worker_id"]: [annotation]
                }

        self.extractRisks()
        self.extractImageDimensions()
        self.extractCompletionStates()
        self.extractAnnotations()

    def extractRisks(self):
        self.risks = {
            int(imageId): image["risk"]
            for imageId, image in self.aggregatedData["images"].items()
        }

    def extractSkillSigmas(self):
        self.skillSigmas = {
            int(np.nan_to_num(float(workerId))): worker["sigma"]
            for workerId, worker in self.aggregatedData["workers"].items()
        }

    def extractSkillFalsePosProbs(self):
        self.skillFalsePosProbs = {
            int(np.nan_to_num(float(workerId))): worker["prob_fp"]
            for workerId, worker in self.aggregatedData["workers"].items()
        }

    def extractSkillFalseNegProbs(self):
        self.skillFalseNegProbs = {
            int(np.nan_to_num(float(workerId))): worker["prob_fn"]
            for workerId, worker in self.aggregatedData["workers"].items()
        }

    def extractSubjectClassificationCounts(self):
        self.subjectClassificationCounts = {
            int(subjectId): len(subjectAnnotations)
            for subjectId, subjectAnnotations in self.inputAnnotationDict.items()
        }

    def extractCompletionStates(self):
        self.completionStates = {
            int(imageId): image["finished"]
            for imageId, image in self.aggregatedData["images"].items()
        }

    def extractImageDimensions(self):
        self.imageDimensions = {
            int(imageId): (image["width"], image["height"])
            for imageId, image in self.aggregatedData["images"].items()
        }

    def extractAnnotations(self):
        default_category_id = 0
        anno_id = itertools.count(0)

        self.annotations = [
            {
                "image_id": label["image_id"],
                "category_id": default_category_id,
                "bbox": [
                    bbox["x"],
                    bbox["y"],
                    bbox["x2"] - bbox["x"],
                    bbox["y2"] - bbox["y"],
                ],
                "id": next(anno_id),
            }
            for labelCounter, label in enumerate(self.aggregatedData["combined_labels"])
            for bbox in label["label"]["bboxes"]
        ]

    def plotExamples(
        self,
        numExamples,
        gridWidth=3,
        showLegend=False,
        selector=None,
        invertColours=False,
    ):
        unifiedFigureShape = np.array([gridWidth, numExamples // gridWidth])
        unifiedFigurePadSize = 6

        unifiedFigure, unifiedPanels = mplplot.subplots(
            figsize=unifiedFigureShape * unifiedFigurePadSize,
            ncols=unifiedFigureShape[0],
            nrows=unifiedFigureShape[1],
        )

        if showLegend:
            panelSlice = slice(0, -1, 1)
        else:
            panelSlice = slice(None)

        if selector is not None:
            selectedImageMetaData = self.imageMetaData.loc[selector]
        else:
            selectedImageMetaData = self.imageMetaData

        selectedImageIds = np.random.choice(
            selectedImageMetaData.image_id.unique(),
            size=numExamples - int(showLegend),
            replace=False,
        )

        selectedImageMetaData = selectedImageMetaData[
            selectedImageMetaData.image_id.apply(
                lambda imageId: imageId in selectedImageIds
            )
        ]

        allLabels = []
        allHandles = []

        for unifiedPanel, (imageIndex, groundTruth) in zip(
            unifiedPanels.flatten()[panelSlice],
            selectedImageMetaData.groupby(by="image_id"),
        ):

            groundTruth = groundTruth.sort_values(by="subject_id").head(1)
            subjectId = np.asscalar(groundTruth.subject_id)

            imageAnnotations = [
                annotation
                for annotation in self.annotations
                if int(annotation["image_id"]) == subjectId
            ]

            if self.imagePathColumn in groundTruth.columns:
                imagePath = str(groundTruth[self.imagePathColumn].values[0])
                if self.imagePathSuffix is not None:
                    imagePath += self.imagePathSuffix
                #                 print(type(imagePath), imagePath)
                if not os.path.isabs(imagePath):
                    imagePath = os.path.join(self.imageDir, imagePath)
            else:
                imagePath = os.path.join(
                    self.imageDir, "subject_{}.png".format(imageIndex)
                )

            imageData = mplplot.imread(imagePath)
            if invertColours:
                imageData[..., :-1] = (
                    np.ones_like(imageData[..., :-1]) - imageData[..., :-1]
                )
            unifiedPanel.imshow(imageData, origin="lower", zorder=0)

            for imageAnnotation in imageAnnotations:
                unifiedPanel.add_patch(
                    matplotlib.patches.Rectangle(
                        [imageAnnotation["bbox"][0], imageAnnotation["bbox"][1]],
                        imageAnnotation["bbox"][2],
                        imageAnnotation["bbox"][3],
                        ec="k",
                        fc="none",
                        alpha=1,
                        zorder=50,
                        lw=2,
                        label="Consensus",
                    )
                )

            uniqueWorkerIds = np.unique(
                np.concatenate(
                    [
                        [int(np.nan_to_num(float(key))) for key in imageAnnos.keys()]
                        for imageAnnos in self.inputAnnotationDict.values()
                    ]
                )
            )
            for workerId, workerAnnotations in self.inputAnnotationDict[
                str(subjectId)
            ].items():
                workerIndex = np.asscalar(
                    np.flatnonzero(
                        uniqueWorkerIds == int(np.nan_to_num(float((workerId))))
                    )
                )
                for bbox in workerAnnotations[0]["anno"]["bboxes"]:
                    unifiedPanel.add_patch(
                        matplotlib.patches.Rectangle(
                            [bbox["x"], bbox["y"]],
                            bbox["x2"] - bbox["x"],
                            bbox["y2"] - bbox["y"],
                            # Anticipate images being finished
                            # within 10 annotations
                            ec="C{}".format(workerIndex % 10),
                            fc="none",
                            alpha=1,
                            zorder=10,
                            label=str(workerIndex),
                        )
                    )

            unifiedPanel.text(
                0.95,
                0.95,
                "$|\mathcal{{W}}|$ = {}".format(
                    len(self.inputAnnotationDict[str(subjectId)])
                ),
                horizontalalignment="right",
                verticalalignment="top",
                fontdict=dict(color="k" if invertColours else "w", fontsize="x-large"),
                transform=unifiedPanel.transAxes,
            )

            if self.completionStates[subjectId]:
                unifiedPanel.text(
                    0.05,
                    0.95,
                    "COMPLETE",
                    horizontalalignment="left",
                    verticalalignment="top",
                    fontdict=dict(
                        color="k" if invertColours else "w", fontsize="x-large"
                    ),
                    transform=unifiedPanel.transAxes,
                )
            else:
                unifiedPanel.text(
                    0.05,
                    0.95,
                    "INCOMPLETE",
                    horizontalalignment="left",
                    verticalalignment="top",
                    fontdict=dict(
                        color="k" if invertColours else "w", fontsize="x-large"
                    ),
                    transform=unifiedPanel.transAxes,
                )

            unifiedPanel.set_title(
                "Simulated Image {}.\n Risk: {:.4e}".format(
                    subjectId, self.risks[subjectId]
                )
            )

            unifiedPanel.set_xlim(0, self.imageDimensions[subjectId][0])
            unifiedPanel.set_ylim(0, self.imageDimensions[subjectId][0])

            handles, labels = unifiedPanel.get_legend_handles_labels()
            allHandles.extend(handles)
            allLabels.extend(labels)

        uniqueLabels = np.unique(allLabels)
        uniqueLabelIndices = [
            allLabels.index(uniqueLabel) for uniqueLabel in uniqueLabels
        ]

        if showLegend:
            legendAxes = unifiedPanels.flatten()[-1]
            legendAxes.axis("off")
            legendAxes.legend(
                np.array(allHandles)[uniqueLabelIndices],
                np.array(allLabels)[uniqueLabelIndices],
                loc="center",
                fontsize="x-large",
                title="Workers",
            ).get_title().set_fontsize("xx-large")

        mplplot.tight_layout()
        return unifiedFigure, unifiedPanels

    def plotRisks(self, threshold=None, logAxes=False):
        riskAxes = mplplot.figure(figsize=(6, 6)).add_subplot(1, 1, 1)
        riskData = np.fromiter(self.risks.values(), dtype=np.float64)

        incompleteRiskData = [
            risk
            for subjectId, risk in self.risks.items()
            if not self.completionStates[subjectId]
        ]

        completeRiskData = [
            risk
            for subjectId, risk in self.risks.items()
            if self.completionStates[subjectId]
        ]

        if logAxes:
            riskBins = np.logspace(
                np.log10(riskData.min()), np.log10(riskData.max()), riskData.size // 10
            )
            riskAxes.set_xscale("log")
        else:
            riskBins = np.linspace(
                np.log10(riskData.min()), np.log10(riskData.max()), riskData.size // 10
            )

        thresholdInRange = (
            threshold is not None
            and threshold > riskData.min()
            and threshold < riskData.max()
        )

        if thresholdInRange:
            riskBins = np.sort(np.append(riskBins, threshold))

        riskAxes.hist(completeRiskData, bins=riskBins, label="Complete")
        riskAxes.hist(incompleteRiskData, bins=riskBins, label="Incomplete")

        if thresholdInRange:
            riskAxes.axvline(
                x=threshold,
                label="$R_{{thresh}}$ = {:.2e}".format(threshold),
                c="r",
                ls="--",
            )

        riskAxes.set_xlabel("Risk")
        riskAxes.set_ylabel("Subject Count")
        if logAxes:
            riskAxes.set_xscale("log")
        riskAxes.legend()
        mplplot.tight_layout()
        return riskAxes
