import os
import itertools
import json
import matplotlib
import matplotlib.pyplot as mplplot
import pandas as pd
import numpy as np


class BBoxResultsPlotter:
    def __init__(
        self, aggregatedDataPath, imageMetaDataPath, inputAnnotations, imageDir="."
    ):
        """
        Args:
        aggregatedDataPath - Path to a JSON-format aggregator output file.
        imageMetaDataPath - Path to a pickled `pandas.DataFrame` with columns
        that must include "image_id" providing a unique index for  the image to
        be plotted and "subject_id", providing the unique ID generated by the
        Panoptes platform.
        inputAnnotations - A list containing the input annotations provided to
        the aggregator.
        imageDir - Path to directory containing the annotated images.
        """
        with open(aggregatedDataPath) as aggregatedDataFile:
            self.aggregatedData = json.load(aggregatedDataFile)
        self.imageMetaData = pd.read_pickle(imageMetaDataPath)
        # self.inputData = inputData
        self.imageDir = imageDir
        self.risks = None
        self.imageDimensions = None
        self.completionStates = None
        self.annotations = None
        self.inputAnnotations = inputAnnotations
        self.inputAnnotationDict = {}

    def processInputData(self):
        for annotation in self.inputAnnotations:
            if annotation["image_id"] in self.inputAnnotationDict:
                if (
                    annotation["worker_id"]
                    in self.inputAnnotationDict[annotation["image_id"]]
                ):
                    self.inputAnnotationDict[annotation["image_id"]][
                        annotation["worker_id"]
                    ].append(annotation)
                else:
                    self.inputAnnotationDict[annotation["image_id"]][
                        annotation["worker_id"]
                    ] = [annotation]
            else:
                self.inputAnnotationDict[annotation["image_id"]] = {
                    annotation["worker_id"]: [annotation]
                }

        self.extractRisks()
        self.extractImageDimensions()
        self.extractCompletionStates()
        self.extractAnnotations()

    def extractRisks(self):
        self.risks = {
            int(imageId): image["risk"]
            for imageId, image in self.aggregatedData["images"].items()
        }

    def extractCompletionStates(self):
        self.completionStates = {
            int(imageId): image["finished"]
            for imageId, image in self.aggregatedData["images"].items()
        }

    def extractImageDimensions(self):
        self.imageDimensions = {
            int(imageId): (image["width"], image["height"])
            for imageId, image in self.aggregatedData["images"].items()
        }

    def extractAnnotations(self):
        default_category_id = 0
        anno_id = itertools.count(0)

        self.annotations = [
            {
                "image_id": label["image_id"],
                "category_id": default_category_id,
                "bbox": [
                    bbox["x"],
                    bbox["y"],
                    bbox["x2"] - bbox["x"],
                    bbox["y2"] - bbox["y"],
                ],
                "id": next(anno_id),
            }
            for labelCounter, label in enumerate(self.aggregatedData["combined_labels"])
            for bbox in label["label"]["bboxes"]
        ]

    def plotExamples(self, numExamples, gridWidth=3, showLegend=False, selector=None):
        unifiedFigureShape = np.array([gridWidth, numExamples // gridWidth])
        unifiedFigurePadSize = 6

        unifiedFigure, unifiedPanels = mplplot.subplots(
            figsize=unifiedFigureShape * unifiedFigurePadSize,
            ncols=unifiedFigureShape[1],
            nrows=unifiedFigureShape[0],
        )

        if showLegend:
            panelSlice = slice(0, -1, 1)
        else:
            panelSlice = slice(None)

        if selector is not None:
            selectedImageMetaData = self.imageMetaData.loc[selector]
        else:
            selectedImageMetaData = self.imageMetaData

        selectedImageIds = np.random.choice(
            selectedImageMetaData.image_id.unique(),
            size=numExamples - int(showLegend),
            replace=False,
        )

        selectedImageMetaData = selectedImageMetaData[
            selectedImageMetaData.image_id.apply(
                lambda imageId: imageId in selectedImageIds
            )
        ]

        for unifiedPanel, (imageIndex, groundTruth) in itertools.zip_longest(
            unifiedPanels.flatten()[panelSlice],
            selectedImageMetaData.groupby(by="image_id"),
        ):

            subjectId = np.asscalar(groundTruth.subject_id.unique())

            imageAnnotations = [
                annotation
                for annotation in self.annotations
                if int(annotation["image_id"]) == subjectId
            ]

            if "image_path" in groundTruth.columns:
                imagePath = groundTruth.image_path
                if not os.path.isabs(imagePath):
                    imagePath = os.path.join(self.imageDir, imagePath)
            else:
                imagePath = os.path.join(
                    self.imageDir, "subject_{}.png".format(imageIndex)
                )

            unifiedPanel.imshow(mplplot.imread(imagePath), origin="lower", zorder=0)

            for imageAnnotation in imageAnnotations:
                unifiedPanel.add_patch(
                    matplotlib.patches.Rectangle(
                        [imageAnnotation["bbox"][0], imageAnnotation["bbox"][1]],
                        imageAnnotation["bbox"][2],
                        imageAnnotation["bbox"][3],
                        ec="k",
                        fc="none",
                        alpha=1,
                        zorder=50,
                        lw=2,
                        label="Consensus",
                    )
                )

            uniqueWorkerIds = np.unique(
                np.concatenate(
                    [
                        [int(key) for key in imageAnnos.keys()]
                        for imageAnnos in self.inputAnnotationDict.values()
                    ]
                )
            )
            for workerId, workerAnnotations in self.inputAnnotationDict[
                str(subjectId)
            ].items():
                workerIndex = np.asscalar(
                    np.flatnonzero(uniqueWorkerIds == int(workerId))
                )
                for bbox in workerAnnotations[0]["anno"]["bboxes"]:
                    unifiedPanel.add_patch(
                        matplotlib.patches.Rectangle(
                            [bbox["x"], bbox["y"]],
                            bbox["x2"] - bbox["x"],
                            bbox["y2"] - bbox["y"],
                            # Anticipate images being finished
                            # within 10 annotations
                            ec="C{}".format(workerIndex % 10),
                            fc="none",
                            alpha=1,
                            zorder=10,
                            label=str(workerIndex),
                        )
                    )

            if self.completionStates[subjectId]:
                unifiedPanel.text(
                    0.05,
                    0.95,
                    "COMPLETE",
                    horizontalalignment="left",
                    verticalalignment="top",
                    fontdict=dict(color="r", fontsize="x-large"),
                    transform=unifiedPanel.transAxes,
                )

            unifiedPanel.set_title(
                "Simulated Image {}.\n Risk: {:.4e}".format(
                    subjectId, self.risks[subjectId]
                )
            )

            unifiedPanel.set_xlim(0, self.imageDimensions[subjectId][0])
            unifiedPanel.set_ylim(0, self.imageDimensions[subjectId][0])

        handles, labels = unifiedPanel.get_legend_handles_labels()

        uniqueLabels = np.unique(labels)
        uniqueLabelIndices = [labels.index(uniqueLabel) for uniqueLabel in uniqueLabels]

        if showLegend:
            legendAxes = unifiedPanels.flatten()[-1]
            legendAxes.axis("off")
            legendAxes.legend(
                np.array(handles)[uniqueLabelIndices],
                np.array(labels)[uniqueLabelIndices],
                loc="center",
                fontsize="x-large",
                title="Workers",
            ).get_title().set_fontsize("xx-large")

        mplplot.tight_layout()
        return unifiedFigure, unifiedPanels

    def plotRisks(self, threshold=None, logAxes = False):
        riskAxes = mplplot.figure(figsize=(6, 6)).add_subplot(1, 1, 1)
        riskData = np.fromiter(self.risks.values(), dtype=np.float64)

        incompleteRiskData = [
            risk
            for subjectId, risk in self.risks.items()
            if not self.completionStates[subjectId]
        ]

        completeRiskData = [
            risk
            for subjectId, risk in self.risks.items()
            if self.completionStates[subjectId]
        ]

        if logAxes:
            riskBins = np.logspace(
                np.log10(riskData.min()), np.log10(riskData.max()), riskData.size // 10
            )
            riskAxes.set_xscale("log")
        else:
            riskBins = np.linspace(
                np.log10(riskData.min()), np.log10(riskData.max()), riskData.size // 10
            )

        thresholdInRange = (
            threshold is not None
            and threshold > riskData.min()
            and threshold < riskData.max()
        )

        if thresholdInRange:
            riskBins = np.sort(np.append(riskBins, threshold))

        riskAxes.hist(completeRiskData, bins=riskBins, label="Complete")
        riskAxes.hist(incompleteRiskData, bins=riskBins, label="Incomplete")

        if thresholdInRange:
            riskAxes.axvline(
                x=threshold,
                label="$R_{{thresh}}$ = {:.2e}".format(threshold),
                c="r",
                ls="--",
            )

        riskAxes.set_xlabel("Risk")
        riskAxes.set_xscale("log")
        riskAxes.set_ylabel("Subject Count")
        if logAxes:
            riskAxes.set_xscale("log")
        riskAxes.legend()
        mplplot.tight_layout()
        return riskAxes
